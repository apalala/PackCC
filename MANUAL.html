<div class="markdown_content"><h1 id="overview">Overview</h1>
<p>PackCC is a packrat parser generator for C. Its main features are as follows:</p>
<ul>
<li>Generates your parser in C from a grammar described in a <strong>PEG</strong>.</li>
<li>Gives your parser great efficiency by <strong>packrat parsing</strong>.</li>
<li>Supports direct and indirect <strong>left-recursive</strong> grammar rules.</li>
</ul>
<p>The grammar of your parser can be described in a <strong>PEG</strong> (<a class="" href="http://en.wikipedia.org/wiki/Parsing_expression_grammar" rel="nofollow">Parsing Expression Grammar</a>). The PEG is a <a class="" href="http://en.wikipedia.org/wiki/Top-down_parsing_language" rel="nofollow">top-down parsing language</a>, and is similar to the <a class="" href="http://en.wikipedia.org/wiki/Regular_expression" rel="nofollow">regular-expression</a> grammar. Compared with a bottom-up parsing language, like Yacc's one, the PEG is much more intuitive and cannot be ambiguous. The PEG does not require tokenization to be a separate step, and tokenization rules can be written in the same way as any other grammar rules.</p>
<p>Your generated parser can parse inputs very efficiently by <strong>packrat parsing</strong>. The packrat parsing is the <a class="" href="http://en.wikipedia.org/wiki/Recursive_descent_parser" rel="nofollow">recursive descent parsing</a> algorithm that is accelerated using <a class="" href="http://en.wikipedia.org/wiki/Memoization" rel="nofollow">memoization</a>. By using packrat parsing, any input can be parsed in linear time. Without it, however, the resulting parser could exhibit exponential time performance in the worst case due to the unlimited look-ahead capability.</p>
<p>Unlike common packrat parsers, PackCC can support direct and indirect <strong>left-recursive</strong> grammar rules. This powerful feature enables you to describe your language grammar in a much simpler way.<br>
<small>(The algorithm is based on the paper <a class="" href="http://www.cs.ucla.edu/~todd/research/pub.php?id=pepm08" rel="nofollow"><em>"Packrat Parsers Can Support Left Recursion"</em></a> authored by A. Warth, J. R. Douglass, and T. Millstein.)</small></p>
<p>Some additional features are as follows:</p>
<ul>
<li>Thread-safe and reentrant.</li>
<li>Generates more ease-of-understanding parser source codes.</li>
<li>Consists of just a single compact source file.</li>
<li>Under MIT license. (not under a certain contagious license!)</li>
</ul>
<p>The generated code is beautified and as ease-of-understanding as possible. Actually, it uses lots of <em>goto</em> statements, but the control flows are much more traceable than <em>goto</em> spaghetti storms generated by Yacc or other parser generators. This feature is irrelevant to common users, but helpful for PackCC developers to debug it.</p>
<p>PackCC itself is under MIT license, but you can distribute your generated code under any license you like.</p>
<h1 id="installation">Installation</h1>
<p>PackCC consists of just a single compact source file <a class="" href="/projects/packcc/files/"><code>packcc.c</code></a>. So, you can obtain the executable <code>packcc</code> just by a simple compile command.</p>
<div class="codehilite"><pre><span></span>cc -o packcc packcc.c
</pre></div>


<p>It can also be compiled using Microsoft Visual C++. To do this, project setup is somewhat bothersome, though.<br>
<small>(I use a useful debugging functionality of Microsoft Visual C++ to detect memory leaks of PackCC itself and generated parsers.)</small></p>
<h1 id="usage">Usage</h1>
<h2 id="command">Command</h2>
<p>You must prepare a PEG source file (see the following section). Let the file name <code>example.peg</code> for example.</p>
<div class="codehilite"><pre><span></span>packcc example.peg
</pre></div>


<p>By running this, the parser source <code>example.h</code> and <code>example.c</code> are generated.</p>
<p>If no PEG file name is specified, the PEG source is read from the standard input, and <code>-.h</code> and <code>-.c</code> are generated.</p>
<p>The base name of the parser source files can be changed by <code>-o</code> option.</p>
<div class="codehilite"><pre><span></span>packcc -o parser example.peg
</pre></div>


<p>By running this, the parser source <code>parser.h</code> and <code>parser.c</code> are generated.</p>
<p>If you want to confirm the version of the <code>packcc</code> command, execute the below.</p>
<div class="codehilite"><pre><span></span>packcc -v
</pre></div>


<h2 id="syntax">Syntax</h2>
<p>A grammar consists of a set of named rules. A rule definition can be split into multiple lines.</p>
<p><strong><em>rulename</em> <code>&lt;-</code> <em>pattern</em></strong></p>
<p>The <em>rulename</em> is the name of the rule to define. The <em>pattern</em> is a text pattern that contains one or more of the following elements.</p>
<p><strong><em>rulename</em></strong></p>
<p>The element stands for the entire pattern in the rule with the name given by <em>rulename</em>.</p>
<p><strong><em>variable</em><code>:</code><em>rulename</em></strong></p>
<p>The element stands for the entire pattern in the rule with the name given by <em>rulename</em>. The <em>variable</em> is an identifier associated with the semantic value returned from the rule by assigning to <code>$$</code> in its action. The identifier can be referred to in subsequent actions as a variable. The example is shown below.</p>
<div class="codehilite"><pre><span></span>term &lt;- l:term _ '+' _ r:factor { $$ = l + r; }
</pre></div>


<p><strong><em>sequence1</em> <code>/</code> <em>sequence2</em> <code>/</code> ... <code>/</code> <em>sequenceN</em></strong></p>
<p>Each <em>sequence</em> is tried in turn until one of them matches, at which time matching for the overall pattern succeeds. If no <em>sequence</em> matches then the matching for the overall pattern fails. The operator slash (<code>/</code>) has the least priority. The example is shown below.</p>
<div class="codehilite"><pre><span></span>'foo' rule1 / 'bar'+ [0-9]? / rule2
</pre></div>


<p>This pattern tries matching of the first sequence (<code>'foo' rule1</code>). If it succeeds, then the overall pattern matching succeeds and ends without evaluating the subsequent sequences. Otherwise, it tries matching of the next sequence (<code>'bar'+ [0-9]?</code>). If it succeeds, then the overall pattern matching succeeds and ends without evaluating the subsequent sequence. Finally, it tries matching of the last sequence (<code>rule2</code>). If it succeeds, then the overall pattern matching succeeds. Otherwise, the overall pattern matching fails.</p>
<p><strong><code>'</code><em>string</em><code>'</code></strong></p>
<p>A character or string enclosed in single quotes is matched literally. The ANSI C escape sequences are recognized within the characters. The example is shown below.</p>
<div class="codehilite"><pre><span></span>'foo bar'
</pre></div>


<p><strong><code>"</code><em>string</em><code>"</code></strong></p>
<p>A character or string enclosed in double quotes is matched literally. The ANSI C escape sequences are recognized within the characters. The example is shown below.</p>
<div class="codehilite"><pre><span></span>"foo bar"
</pre></div>


<p><strong><code>[</code><em>character class</em><code>]</code></strong></p>
<p>A set of characters enclosed in square brackets matches any single character from the set. The ANSI C escape sequences are recognized within the characters. If the set begins with an up-arrow (<code>^</code>), the set is negated (the element matches any character not in the set). Any pair of characters separated with a dash (<code>-</code>) represents the range of characters from the first to the second, inclusive. The examples are shown below.</p>
<div class="codehilite"><pre><span></span>[abc]
[^abc]
[a-zA-Z0-9_]
</pre></div>


<p><strong><code>.</code></strong></p>
<p>A dot (<code>.</code>) matches any single character. Note that the only time this fails is at the end of input, where there is no character to match.</p>
<p><strong><em>element</em> <code>?</code></strong></p>
<p>The <em>element</em> is optional. If present on the input, it is consumed and the match succeeds. If not present on the input, no text is consumed and the match succeeds anyway.</p>
<p><strong><em>element</em> <code>*</code></strong></p>
<p>The <em>element</em> is optional and repeatable. If present on the input, one or more occurrences of the <em>element</em> are consumed and the match succeeds. If no occurrence of the <em>element</em> is present on the input, the match succeeds anyway.</p>
<p><strong><em>element</em> <code>+</code></strong></p>
<p>The <em>element</em> is repeatable. If present on the input, one or more occurrences of the <em>element</em> are consumed and the match succeeds. If no occurrence of the <em>element</em> is present on the input, the match fails.</p>
<p><strong><code>&amp;</code> <em>element</em></strong></p>
<p>The predicate succeeds only if the <em>element</em> can be matched. The input text scanned while matching <em>element</em> is not consumed from the input and remains available for subsequent matching.</p>
<p><strong><code>!</code> <em>element</em></strong></p>
<p>The predicate succeeds only if the <em>element</em> cannot be matched. The input text scanned while matching <em>element</em> is not consumed from the input and remains available for subsequent matching. A popular idiom is the following, which matches the end of input, after the last character of the input has already been consumed.</p>
<div class="codehilite"><pre><span></span>!.
</pre></div>


<p><strong><code>(</code> <em>pattern</em> <code>)</code></strong></p>
<p>Parentheses are used for grouping (modifying the precedence of the <em>pattern</em>).</p>
<p><strong><code>&lt;</code> <em>pattern</em> <code>&gt;</code></strong></p>
<p>Angle brackets are used for grouping (modifying the precedence of the <em>pattern</em>) and text capturing. The captured text is numbered in evaluation order, and can be referred to later using <code>$1</code>, <code>$2</code>, etc.</p>
<p><strong><code>$</code><em>n</em></strong></p>
<p>A dollar (<code>$</code>) followed by a positive integer represents a text previously captured. The positive integer corresponds to the order of capturing. A <code>$1</code> represents the first captured text. The examples are shown below.</p>
<div class="codehilite"><pre><span></span>&lt; [0-9]+ &gt; 'foo' $1
</pre></div>


<p>This matches <code>0foo0</code>, <code>123foo123</code>, etc.</p>
<div class="codehilite"><pre><span></span>'[' &lt; '='* &gt; '[' !( ']' $1 ']' ) . )* ( ']' $1 ']' )
</pre></div>


<p>This matches <code>[[</code>...<code>]]</code>, <code>[=[</code>...<code>]=]</code>, <code>[==[</code>...<code>]==]</code>, etc.</p>
<p><strong><code>{</code> <em>c source code</em> <code>}</code></strong></p>
<p>Curly braces surround an action. The action is arbitrary C source code to be executed at the end of matching. Any braces within the action must be properly nested. One or more actions can be inserted in any places between elements in the pattern. Actions are not executed where matching fails.</p>
<div class="codehilite"><pre><span></span>[0-9]+ 'foo' { puts("OK"); } 'bar' / [0-9]+ 'foo' 'baz'
</pre></div>


<p>In this example, if the input is <code>012foobar</code>, the action <code>{ puts("OK"); }</code> is to be executed, but if the input is <code>012foobaz</code>, the action is not to be executed. All matched actions are guaranteed to be executed only once.</p>
<p>In the action, the C source code can use the predefined variables below.</p>
<ul>
<li><strong><code>$$</code></strong> <br>
    The output variable, to which the result of the rule is stored.</li>
<li><strong><code>auxil</code></strong><br>
    The user-defined data that is passed to the API function <code>pcc_create()</code>.</li>
<li><em>variable</em><br>
    The result of the evaluated rule, which has been stored to the variable <code>$$</code> in the action in the evaluated rule.</li>
<li><strong><code>$</code></strong><em>n</em><br>
    The string of the captured text. The <em>n</em> is the positive integer that corresponds to the order of capturing. The variable <code>$1</code> holds the string of the first captured text.</li>
<li><strong><code>$</code></strong><em>n</em><strong><code>s</code></strong><br>
    The start position in the input of the captured text, inclusive. The <em>n</em> is the positive integer that corresponds to the order of capturing. The variable <code>$1s</code> holds the start position of the first captured text.</li>
<li><strong><code>$</code></strong><em>n</em><strong><code>e</code></strong><br>
    The end position in the input of the captured text, exclusive. The <em>n</em> is the positive integer that corresponds to the order of capturing. The variable <code>$1e</code> holds the end position of the first captured text.</li>
<li><strong><code>$0</code></strong><br>
    The string of the text between the start position in the input at which the rule pattern begins to match and the current position in the input at which the element immediately before the action ends to match.</li>
<li><strong><code>$0s</code></strong><br>
    The start position in the input at which the rule pattern begins to match.</li>
<li><strong><code>$0e</code></strong><br>
    The current position in the input at which the element immediately before the action ends to match.</li>
</ul>
<p>The example is shown below.</p>
<div class="codehilite"><pre><span></span>term &lt;- l:term _ '+' _ r:factor { $$ = l + r; }
factor &lt;- &lt; [0-9]+ &gt;            { $$ = atoi($1); }
_ &lt;- [ \t]*
</pre></div>


<p><strong><em>element</em> <code>~</code> <code>{</code> <em>c source code</em> <code>}</code></strong></p>
<p>Curly braces following tilde (<code>~</code>) surround an error action. The error action is arbitrary C source code to be executed at the end of matching only if the preceding <em>element</em> matching fails. Any braces within the error action must be properly nested. One or more error actions can be inserted in any places after elements in the pattern. The operator tilde (<code>~</code>) binds less tightly than any other operator except alternation (<code>/</code>) and sequencing. The error action is intended to make error handling and recovery code easier to write. In the error action, all predefined variables described above are available as well. The examples are shown below.</p>
<div class="codehilite"><pre><span></span>rule1 &lt;- e1 e2 e3 ~{ error("e[12] ok; e3 has failed"); }
rule2 &lt;- (e1 e2 e3) ~{ error("one of e[123] has failed"); }
</pre></div>


<p><strong><code>%header</code> <code>{</code> <em>c source code</em> <code>}</code></strong></p>
<p>The specified C source code is copied verbatim to the C header file before the generated parser API function declarations.</p>
<p><strong><code>%source</code> <code>{</code> <em>c source code</em> <code>}</code></strong></p>
<p>The specified C source code is copied verbatim to the C source file before the generated parser implementation code.</p>
<p><strong><code>%common</code> <code>{</code> <em>c source code</em> <code>}</code></strong></p>
<p>The specified C source code is copied verbatim to both of the C header file and the C source file before the generated parser API function declarations and the implementation code respectively.</p>
<p><strong><code>%value</code> <code>"</code><em>output data type</em><code>"</code></strong></p>
<p>The type of output data, which is retrieved from the parser API function <code>pcc_parse()</code>, is changed to the specified one from the default <code>int</code>.</p>
<p><strong><code>%auxil</code> <code>"</code><em>user-defined data type</em><code>"</code></strong></p>
<p>The type of user-defined data, which is passed to the parser API function <code>pcc_create()</code>, is changed to the specified one from the default <code>void *</code>.</p>
<p><strong><code>%prefix</code> <code>"</code><em>prefix</em><code>"</code></strong></p>
<p>The prefix of the parser API functions is changed to the specified one from the default <code>pcc</code>.</p>
<p><strong><code>#</code><em>comment</em></strong></p>
<p>A comment can be inserted between <code>#</code> and the end of the line.</p>
<p><strong><code>%%</code></strong></p>
<p>A double percent <code>%%</code> terminates the section for rule definitions of the grammar. All text following <code>%%</code> is copied verbatim to the C source file after the generated parser implementation code.</p>
<p><small>(The specification is determined by referring to <a class="" href="http://piumarta.com/software/peg/" rel="nofollow">peg/leg</a> developed by Ian Piumarta.)</small></p>
<h2 id="macro">Macro</h2>
<p>Some macros are prepared to customize the parser. The macro definition should be in <u><code>%source</code> section</u> in the PEG source.</p>
<div class="codehilite"><pre><span></span>%source {
    #define PCC_GETCHAR(auxil) get_character(auxil-&gt;input)
    #define PCC_BUFFERSIZE 1024
}
</pre></div>


<p>The following macros are available.</p>
<p><strong><code>PCC_GETCHAR(</code></strong><em>auxil</em><strong><code>)</code></strong></p>
<p>The function macro to get a character from the input. The user-defined data passed to the API function <code>pcc_create()</code> can be retrieved from the argument <em>auxil</em>. It can be ignored if no user-defined data. This macro must return a character code as an <code>int</code> type, or <code>-1</code> if the input ends.</p>
<p>The default is defined as below.</p>
<div class="codehilite"><pre><span></span><span class="cp">#define PCC_GETCHAR(auxil) getchar()</span>
</pre></div>


<p><strong><code>PCC_ERROR(</code></strong><em>auxil</em><strong><code>)</code></strong></p>
<p>The function macro to handle a syntax error. The user-defined data passed to the API function <code>pcc_create()</code> can be retrieved from the argument <em>auxil</em>. It can be ignored if no user-defined data. This macro need not return a value. It may abort the process (by using <code>exit()</code> for example) when a fatal error occurs, and can also return normally to deal with warnings.</p>
<p>The default is defined as below.</p>
<div class="codehilite"><pre><span></span><span class="cp">#define PCC_ERROR(auxil) pcc_error()</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pcc_error</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Syntax error</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p><strong><code>PCC_MALLOC(</code></strong><em>auxil</em><strong><code>,</code></strong><em>size</em><strong><code>)</code></strong></p>
<p>The function macro to allocate a memory block. The user-defined data passed to the API function <code>pcc_create()</code> can be retrieved from the argument <em>auxil</em>. It can be ignored if no user-defined data. The argument <em>size</em> is the number of bytes to allocate. This macro must return a pointer to the allocated memory block, or <code>NULL</code> if no sufficient memory is available.</p>
<p>The default is defined as below.</p>
<div class="codehilite"><pre><span></span><span class="cp">#define PCC_MALLOC(auxil, size) pcc_malloc_e(size)</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">pcc_malloc_e</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Out of memory</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p><strong><code>PCC_REALLOC(</code></strong><em>auxil</em><strong><code>,</code></strong><em>ptr</em><strong><code>,</code></strong><em>size</em><strong><code>)</code></strong></p>
<p>The function macro to reallocate the existing memory block. The user-defined data passed to the API function <code>pcc_create()</code> can be retrieved from the argument <em>auxil</em>. It can be ignored if no user-defined data. The argument <em>ptr</em> is the pointer to the previously allocated memory block. The argument <em>size</em> is the new number of bytes to reallocate. This macro must return a pointer to the reallocated memory block, or <code>NULL</code> if no sufficient memory is available. The contents of the memory block should be left unchanged in any case even if the reallocation fails.</p>
<p>The default is defined as below.</p>
<div class="codehilite"><pre><span></span><span class="cp">#define PCC_REALLOC(auxil, ptr, size) pcc_realloc_e(ptr, size)</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">pcc_realloc_e</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Out of memory</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p><strong><code>PCC_FREE(</code></strong><em>auxil</em><strong><code>,</code></strong><em>ptr</em><strong><code>)</code></strong></p>
<p>The function macro to free the existing memory block. The user-defined data passed to the API function <code>pcc_create()</code> can be retrieved from the argument <em>auxil</em>. It can be ignored if no user-defined data. The argument <em>ptr</em> is the pointer to the previously allocated memory block. This macro need not return a value.</p>
<p>The default is defined as below.</p>
<div class="codehilite"><pre><span></span><span class="cp">#define PCC_FREE(auxil, ptr) free(ptr)</span>
</pre></div>


<p><strong><code>PCC_BUFFERSIZE</code></strong></p>
<p>The initial size (the number of characters) of the text buffer. The text buffer is expanded as needed. The default is <code>256</code>.</p>
<p><strong><code>PCC_ARRAYSIZE</code></strong></p>
<p>The initial size (the number of elements) of the internal arrays other than the text buffer. The arrays are expanded as needed. The default is <code>2</code>.</p>
<h2 id="api">API</h2>
<p>The parser API has only 3 simple functions below.</p>
<div class="codehilite"><pre><span></span><span class="n">pcc_context_t</span> <span class="o">*</span><span class="nf">pcc_create</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">auxil</span><span class="p">);</span>
</pre></div>


<p>Creates a parser context. This context needs to be passed to the functions below. The <code>auxil</code> can be used to pass user-defined data to be bound to the context. <code>NULL</code> can be specified if no user-defined data.</p>
<div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="nf">pcc_parse</span><span class="p">(</span><span class="n">pcc_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ret</span><span class="p">);</span>
</pre></div>


<p>Parses an input text (from standard input by default) and returns the result in <code>ret</code>. The <code>ret</code> can be <code>NULL</code> if no output data is needed. This function returns <code>0</code> if no text is left to be parsed, or a non-<code>0</code> value otherwise.</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="nf">pcc_destroy</span><span class="p">(</span><span class="n">pcc_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">);</span>
</pre></div>


<p>Destroys the parser context. All resources allocated in the parser context are released.</p>
<p>The type of output data <code>ret</code> can be changed. If you want change it to <code>char *</code>, specify <code>%value "char *"</code> in the PEG source. The default is <code>int</code>.</p>
<p>The type of user-defined data <code>auxil</code> can be changed. If you want change it to <code>long</code>, specify <code>%auxil "long"</code> in the PEG source. The default is <code>void *</code>.</p>
<p>The prefix <code>pcc</code> can be changed. If you want change it to <code>foo</code>, specify <code>%prefix "foo"</code> in the PEG source. The default is <code>pcc</code>.</p>
<p>After the above settings, the API functions change like below.</p>
<div class="codehilite"><pre><span></span><span class="n">foo_context_t</span> <span class="o">*</span><span class="nf">foo_create</span><span class="p">(</span><span class="kt">long</span> <span class="n">auxil</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">foo_parse</span><span class="p">(</span><span class="n">foo_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">ret</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">foo_destroy</span><span class="p">(</span><span class="n">foo_context_t</span> <span class="o">*</span><span class="n">ctx</span><span class="p">);</span>
</pre></div>


<p>The typical usage of the API functions is shown below.</p>
<div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
<span class="n">pcc_context_t</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">pcc_create</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="k">while</span> <span class="p">(</span><span class="n">pcc_parse</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret</span><span class="p">));</span>
<span class="n">pcc_destroy</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
</pre></div>


<h1 id="example">Example</h1>
<p>A desktop calculator. Note that there are <strong>left-recursive</strong> grammar rules.</p>
<div class="codehilite"><pre><span></span>%prefix "calc"

statement &lt;- _ e:expression _ EOL { printf("answer=%d\n", e); }
           / ( !EOL . )* EOL      { printf("error\n"); }

expression &lt;- e:term { $$ = e; }

term &lt;- l:term _ '+' _ r:factor { $$ = l + r; }
      / l:term _ '-' _ r:factor { $$ = l - r; }
      / e:factor                { $$ = e; }

factor &lt;- l:factor _ '*' _ r:unary { $$ = l * r; }
        / l:factor _ '/' _ r:unary { $$ = l / r; }
        / e:unary                  { $$ = e; }

unary &lt;- '+' _ e:unary { $$ = +e; }
       / '-' _ e:unary { $$ = -e; }
       / e:primary     { $$ = e; }

primary &lt;- &lt; [0-9]+ &gt;               { $$ = atoi($1); }
         / '(' _ e:expression _ ')' { $$ = e; }

_      &lt;- [ \t]*
EOL    &lt;- '\n' / '\r\n' / '\r' / ';'

%%
int main() {
    calc_context_t *ctx = calc_create(NULL);
    while (calc_parse(ctx, NULL));
    calc_destroy(ctx);
    return 0;
}
</pre></div>


<h6>Project Members:</h6>
	<ul class="md-users-list">
		<li><a href="/u/arithy/">Arihiro Yoshida</a> (admin)</li>

	</ul>
</div>
